#include <iostream>
#include <vector>
#include <limits>
using namespace std;

int main() {
    setlocale(LC_ALL, "RU");
    int n;
    cout << "Введите размер матрицы(n) *дробная часть числа будет удалена автоматически* : ";
    while (!(cin >> n) || n <= 0) {
        cout << "Введите целое положительное число для n: ";
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
    }

    int nook;
    cout << "Выберите начальный угол (1 - верхний левый, 2 - верхний правый, 3 - нижний левый, 4 - нижний правый): ";
    cin >> nook;

    if (nook < 1 || nook > 4) {
        cout << "Неверный выбор угла." << endl;
        return 1;
    }

    vector<vector<int> > matrix(n, vector<int>(n));
    int num = 1;
    // Определяем инверсию по осям X и Y в зависимости от выбранного угла
    bool invertX = (nook == 3 || nook == 4);
    bool invertY = (nook == 2 || nook == 4);
    // s - номер диагонали
    for (int s = 0; s < n * 2 - 1; ++s) {
        int x, y; // Координаты начальной точки на диагонали
        int dx, dy; // Направления изменения координат на диагонали
        // Определяем начальные координаты и направления для текущей диагонали
        if (s % 2 == 0) {
            // Четная диагональ: начинаем движение вверх-вправо
            // Устанавливаем начальные значения x и y в зависимости от номера диагонали
            x = (s < n) ? s : n - 1; // Если s < n, начинаем с x = s; иначе с нижней границы x = n - 1
            y = (s < n) ? 0 : s - n + 1; // Если s < n, начинаем с левой границы y = 0; иначе со смещением y = s - n + 1
            dx = -1; // движение вверх
            dy = 1; // движение вправо
        }
        else { // Нечетные диагонали - вниз-влево
            // Нечетная диагональ: начинаем движение вниз-влево
            x = (s < n) ? 0 : s - n + 1; // Если s < n, начинаем с верхней границы x = 0; иначе — со смещением x = s - n + 1
            y = (s < n) ? s : n - 1; // Если s < n, начинаем с y = s на верхней границе; иначе — с правой границы y = n - 1
            dx = 1; // движение вниз
            dy = -1; // движение влево
        }
        /*
            Внутренний цикл для перемещения по текущей диагонали.
            Двигаемся до тех пор, пока не выйдем за границы матрицы.
        */
        while (x >= 0 && x < n && y >= 0 && y < n) {
            // Применение инверсии в зависимости от выбранного начального угла
            // Если invertX или invertY установлены в true, индексы x и/или y будут инвертированы
            int xi = invertX ? n - 1 - x : x; // Инвертируем x
            int yi = invertY ? n - 1 - y : y; // Инвертируем y
            // Присваиваем значение и увеличиваем num для следующей ячейки
            matrix[xi][yi] = num++;
            x += dx; // Переход по x на следующую позицию на диагонали
            y += dy; // Переход по y на следующую позицию на диагонали
        }
    }
    // вывод готовой матрицы
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << matrix[i][j] << "\t";
        }
        cout << endl;
    }
    return 0;
}